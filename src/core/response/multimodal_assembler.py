"""Multimodal Assembler for combining text and image content.

This module assembles multimodal MCP responses by:
- Detecting image references in chunk metadata
- Reading image files and encoding to base64
- Building MCP-compliant ImageContent blocks

Design Principles:
- Lazy loading: Images only loaded when explicitly requested
- Error resilience: Missing images don't break text response
- Format detection: Automatic MIME type inference from file content
"""

from __future__ import annotations

import base64
import logging
import re
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

from mcp import types

from src.core.types import RetrievalResult


logger = logging.getLogger(__name__)


# Supported image formats and their MIME types
MIME_TYPE_MAP: Dict[str, str] = {
    ".png": "image/png",
    ".jpg": "image/jpeg",
    ".jpeg": "image/jpeg",
    ".gif": "image/gif",
    ".webp": "image/webp",
    ".bmp": "image/bmp",
    ".svg": "image/svg+xml",
}

# Magic bytes for format detection (fallback when extension unreliable)
MAGIC_BYTES: Dict[bytes, str] = {
    b"\x89PNG\r\n\x1a\n": "image/png",
    b"\xff\xd8\xff": "image/jpeg",
    b"GIF87a": "image/gif",
    b"GIF89a": "image/gif",
    b"RIFF": "image/webp",  # WebP starts with RIFF
    b"BM": "image/bmp",
}

# Image placeholder pattern in text: [IMAGE: image_id]
IMAGE_PLACEHOLDER_PATTERN = re.compile(r"\[IMAGE:\s*([^\]]+)\]")


@dataclass
class ImageReference:
    """Reference to an image within a chunk.
    
    Attributes:
        image_id: Unique identifier for the image
        file_path: Filesystem path to the image file
        page: Optional page number in source document
        text_offset: Character offset of placeholder in chunk text
        text_length: Length of the placeholder string
        caption: Optional caption generated by ImageCaptioner
    """
    image_id: str
    file_path: Optional[str] = None
    page: Optional[int] = None
    text_offset: Optional[int] = None
    text_length: Optional[int] = None
    caption: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "image_id": self.image_id,
            "file_path": self.file_path,
            "page": self.page,
            "text_offset": self.text_offset,
            "text_length": self.text_length,
            "caption": self.caption,
        }


@dataclass
class ImageContent:
    """Loaded image content ready for MCP response.
    
    Attributes:
        image_id: Unique identifier for the image
        data: Base64-encoded image data
        mime_type: MIME type (e.g., "image/png")
        caption: Optional caption for the image
    """
    image_id: str
    data: str  # base64 encoded
    mime_type: str
    caption: Optional[str] = None
    
    def to_mcp_content(self) -> types.ImageContent:
        """Convert to MCP ImageContent block.
        
        Returns:
            MCP ImageContent object for protocol response.
        """
        return types.ImageContent(
            type="image",
            data=self.data,
            mimeType=self.mime_type,
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary."""
        return {
            "image_id": self.image_id,
            "data": self.data,
            "mime_type": self.mime_type,
            "caption": self.caption,
        }


class MultimodalAssembler:
    """Assembles multimodal content from retrieval results.
    
    This class extracts image references from chunk metadata,
    loads image files, and builds MCP-compliant content blocks
    combining text and images.
    
    Example:
        >>> assembler = MultimodalAssembler()
        >>> results = [RetrievalResult(chunk_id="doc1_001", ...)]
        >>> content_blocks = assembler.assemble(results)
        >>> # Returns list of TextContent and ImageContent blocks
    
    Args:
        image_storage: Optional ImageStorage instance for path lookup.
            If None, uses file paths directly from metadata.
        max_images_per_result: Maximum images to include per result (default: 5).
        include_captions: Whether to include image captions as text (default: True).
    """
    
    def __init__(
        self,
        image_storage: Optional[Any] = None,
        max_images_per_result: int = 5,
        include_captions: bool = True,
    ) -> None:
        """Initialize MultimodalAssembler.
        
        Args:
            image_storage: Optional ImageStorage for resolving image paths.
            max_images_per_result: Max images to include per retrieval result.
            include_captions: Whether to add caption text blocks.
        """
        self._image_storage = image_storage
        self.max_images_per_result = max_images_per_result
        self.include_captions = include_captions
    
    def extract_image_refs(
        self,
        result: RetrievalResult,
    ) -> List[ImageReference]:
        """Extract image references from a retrieval result.
        
        Looks for image references in:
        1. metadata.images list (structured image info)
        2. [IMAGE: id] placeholders in text (fallback)
        
        Args:
            result: RetrievalResult containing chunk data.
            
        Returns:
            List of ImageReference objects found in the result.
        """
        refs: List[ImageReference] = []
        metadata = result.metadata or {}
        
        # Primary source: structured images list in metadata
        images_list = metadata.get("images", [])
        if isinstance(images_list, list):
            for img_info in images_list[:self.max_images_per_result]:
                if isinstance(img_info, dict) and "id" in img_info:
                    ref = ImageReference(
                        image_id=img_info["id"],
                        file_path=img_info.get("path"),
                        page=img_info.get("page"),
                        text_offset=img_info.get("text_offset"),
                        text_length=img_info.get("text_length"),
                    )
                    refs.append(ref)
        
        # Add captions if available
        captions = metadata.get("image_captions", {})
        if isinstance(captions, dict):
            for ref in refs:
                if ref.image_id in captions:
                    ref.caption = captions[ref.image_id]
        
        # Fallback: parse placeholders from text if no structured refs
        if not refs and result.text:
            placeholders = IMAGE_PLACEHOLDER_PATTERN.findall(result.text)
            for image_id in placeholders[:self.max_images_per_result]:
                image_id = image_id.strip()
                ref = ImageReference(
                    image_id=image_id,
                    caption=captions.get(image_id) if isinstance(captions, dict) else None,
                )
                refs.append(ref)
        
        return refs
    
    def resolve_image_path(
        self,
        ref: ImageReference,
        collection: Optional[str] = None,
    ) -> Optional[str]:
        """Resolve the filesystem path for an image reference.
        
        Args:
            ref: ImageReference to resolve.
            collection: Optional collection name for path construction.
            
        Returns:
            Absolute file path if found, None otherwise.
        """
        # Use explicit path if available
        if ref.file_path:
            path = Path(ref.file_path)
            if path.exists():
                return str(path.resolve())
        
        # Try ImageStorage lookup
        if self._image_storage is not None:
            try:
                path = self._image_storage.get_image_path(ref.image_id)
                if path and Path(path).exists():
                    return path
            except Exception as e:
                logger.warning(f"ImageStorage lookup failed for {ref.image_id}: {e}")
        
        # Convention-based path: data/images/{collection}/{image_id}.png
        if collection:
            from src.core.settings import resolve_path
            for ext in [".png", ".jpg", ".jpeg", ".webp"]:
                candidate = resolve_path(f"data/images/{collection}/{ref.image_id}{ext}")
                if candidate.exists():
                    return str(candidate.resolve())
        
        return None
    
    def load_image(
        self,
        file_path: str,
    ) -> Optional[ImageContent]:
        """Load and encode an image file.
        
        Args:
            file_path: Path to the image file.
            
        Returns:
            ImageContent with base64 data and MIME type, or None on failure.
        """
        try:
            path = Path(file_path)
            if not path.exists():
                logger.warning(f"Image file not found: {file_path}")
                return None
            
            # Read file content
            data = path.read_bytes()
            if not data:
                logger.warning(f"Empty image file: {file_path}")
                return None
            
            # Detect MIME type
            mime_type = self._detect_mime_type(path, data)
            
            # Encode to base64
            base64_data = base64.b64encode(data).decode("utf-8")
            
            return ImageContent(
                image_id=path.stem,
                data=base64_data,
                mime_type=mime_type,
            )
            
        except Exception as e:
            logger.error(f"Failed to load image {file_path}: {e}")
            return None
    
    def _detect_mime_type(
        self,
        path: Path,
        data: bytes,
    ) -> str:
        """Detect MIME type from file extension or magic bytes.
        
        Args:
            path: File path for extension detection.
            data: File content for magic byte detection.
            
        Returns:
            MIME type string (defaults to "image/png" if unknown).
        """
        # Try extension first
        suffix = path.suffix.lower()
        if suffix in MIME_TYPE_MAP:
            return MIME_TYPE_MAP[suffix]
        
        # Fallback to magic bytes
        for magic, mime_type in MAGIC_BYTES.items():
            if data.startswith(magic):
                return mime_type
        
        # Default to PNG
        logger.debug(f"Unknown image format for {path}, defaulting to image/png")
        return "image/png"
    
    def assemble_for_result(
        self,
        result: RetrievalResult,
        collection: Optional[str] = None,
    ) -> List[Union[types.TextContent, types.ImageContent]]:
        """Assemble multimodal content blocks for a single result.
        
        Args:
            result: RetrievalResult to process.
            collection: Optional collection name for path resolution.
            
        Returns:
            List of MCP content blocks (TextContent and ImageContent).
        """
        blocks: List[Union[types.TextContent, types.ImageContent]] = []
        
        # Extract image references
        refs = self.extract_image_refs(result)
        
        # Load and add images
        for ref in refs:
            # Resolve path
            file_path = self.resolve_image_path(ref, collection)
            if not file_path:
                logger.debug(f"Could not resolve path for image: {ref.image_id}")
                continue
            
            # Load image
            image_content = self.load_image(file_path)
            if image_content is None:
                continue
            
            # Update with reference info
            image_content.image_id = ref.image_id
            image_content.caption = ref.caption
            
            # Add image block
            blocks.append(image_content.to_mcp_content())
            
            # Add caption as text if enabled
            if self.include_captions and ref.caption:
                caption_text = f"**Image Caption ({ref.image_id}):** {ref.caption}"
                blocks.append(types.TextContent(type="text", text=caption_text))
        
        return blocks
    
    def assemble(
        self,
        results: List[RetrievalResult],
        collection: Optional[str] = None,
    ) -> List[Union[types.TextContent, types.ImageContent]]:
        """Assemble multimodal content blocks for multiple results.
        
        Args:
            results: List of RetrievalResult to process.
            collection: Optional collection name for path resolution.
            
        Returns:
            List of all MCP content blocks from all results.
        """
        all_blocks: List[Union[types.TextContent, types.ImageContent]] = []
        seen_image_ids: set = set()
        
        for result in results:
            blocks = self.assemble_for_result(result, collection)
            
            # Deduplicate images across results
            for block in blocks:
                if isinstance(block, types.ImageContent):
                    # Check if we've seen this image
                    # ImageContent doesn't have image_id, so we hash the data
                    data_hash = hash(block.data[:100])  # Use prefix for efficiency
                    if data_hash in seen_image_ids:
                        continue
                    seen_image_ids.add(data_hash)
                
                all_blocks.append(block)
        
        return all_blocks
    
    def has_images(self, result: RetrievalResult) -> bool:
        """Check if a result contains image references.
        
        Args:
            result: RetrievalResult to check.
            
        Returns:
            True if result has image references, False otherwise.
        """
        refs = self.extract_image_refs(result)
        return len(refs) > 0
    
    def count_images(self, results: List[RetrievalResult]) -> int:
        """Count total images across all results.
        
        Args:
            results: List of RetrievalResult to count.
            
        Returns:
            Total number of image references found.
        """
        total = 0
        for result in results:
            refs = self.extract_image_refs(result)
            total += len(refs)
        return total
